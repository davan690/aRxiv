<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>aRxiv tutorial</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{aRxiv tutorial}
-->

<h1>aRxiv tutorial</h1>

<p><a href="http://arxiv.org">arXiv</a> is a repository of electronic preprints for
computer science, mathematics, physics, quantitative biology,
quantitative finance, and statistics. The
<a href="https://github.com/ropensci/aRxiv">aRxiv package</a> provides an
<a href="http://www.r-project.org">R</a> interface to the
<a href="http://arxiv.org/help/api/index">arXiv API</a>.</p>

<p>Note that the arXiv API <em>does not</em> require an API key.</p>

<h2>Installation</h2>

<p>You can install the <a href="https://github.com/rOpenSci/aRxiv">aRxiv package</a>
via <a href="http://cran.r-project.org">CRAN</a>:</p>

<pre><code class="r">install.packages(&quot;aRxiv&quot;)
</code></pre>

<p>Or use <code>devtools::install_github()</code> to get the (more recent) version
at <a href="https://github.com/rOpenSci/aRxiv">GitHub</a>:</p>

<pre><code class="r">install.packages(&quot;devtools&quot;)
library(devtools)
install_github(&quot;ropensci/aRxiv&quot;)
</code></pre>

<h2>Basic use</h2>

<p>Use <code>arxiv_search()</code> to search <a href="http://arxiv.org">arXiv</a>,
<code>arxiv_count()</code> to get a simple count of manuscripts matching a
query, and <code>arxiv_open()</code> to open the abstract pages for a set of
results from <code>arxiv_search()</code>.</p>

<p>We&#39;ll get to the details in a moment. For now, let&#39;s look at a few
examples.</p>

<p>Suppose we wanted to identify all arXiv manuscripts with &ldquo;<code>Peter
Hall</code>&rdquo; as an author. It is best to first get a count, so that we have
a sense of how many records the search will return. (Peter Hall is
&ldquo;<a href="http://en.wikipedia.org/wiki/Peter_Gavin_Hall">among the world&#39;s most prolific and highly cited authors in both probability and statistics</a>.&rdquo;)
We first use <code>library()</code> to load the aRxiv package and then
<code>arxiv_count()</code> to get the count.</p>

<pre><code class="r">library(aRxiv)
arxiv_count(&#39;au:&quot;Peter Hall&quot;&#39;)
</code></pre>

<pre><code>## [1] 51
</code></pre>

<p>The <code>au:</code> part indicates to search the author field; we use double
quotes to search for a <em>phrase</em>.</p>

<p>To obtain the actual records matching the query, use <code>arxiv_search()</code>.</p>

<pre><code class="r">rec &lt;- arxiv_search(&#39;au:&quot;Peter Hall&quot;&#39;)
nrow(rec)
</code></pre>

<pre><code>## [1] 10
</code></pre>

<p>The default is to grab no more than 10 records; this limit can be
changed with the <code>limit</code> argument. But note that the arXiv API will
not let you download more than 50,000 or so records, and even in that
case it&#39;s best to do so in batches; more on this below.</p>

<p>Also note that the result of <code>arxiv_search()</code> has an attribute
<code>&quot;total_results&quot;</code> containing the total count of search results; this
is the same as what <code>arxiv_count()</code> provides.</p>

<pre><code class="r">attr(rec, &quot;total_results&quot;)
</code></pre>

<pre><code>## [1] 51
</code></pre>

<p>The following will get us all 51
records.</p>

<pre><code class="r">rec &lt;- arxiv_search(&#39;au:&quot;Peter Hall&quot;&#39;, limit=50)
nrow(rec)
</code></pre>

<pre><code>## [1] 50
</code></pre>

<p><code>arxiv_search()</code> returns a data frame with each row being a single
manuscript. The columns are the different fields (e.g., <code>authors</code>, <code>title</code>,
<code>abstract</code>, etc.). Fields like <code>authors</code> that
contain multiple items will be a single character string with the
multiple items separated by a vertical bar (<code>|</code>).</p>

<p>We might be interested in a more restrictive search, such as for Peter
Hall&#39;s arXiv manuscripts that have <code>deconvolution</code> in the title. We
use <code>ti:</code> to search the title field, and combine the two with <code>AND</code>.</p>

<pre><code class="r">deconv &lt;- arxiv_search(&#39;au:&quot;Peter Hall&quot; AND ti:deconvolution&#39;)
nrow(deconv)
</code></pre>

<pre><code>## [1] 4
</code></pre>

<p>Let&#39;s display just the authors and title for the results.</p>

<pre><code class="r">deconv[, c(&#39;title&#39;, &#39;authors&#39;)]
</code></pre>

<pre><code>##                                                                             title
## 1                                     A ridge-parameter approach to deconvolution
## 2                                     On deconvolution with repeated measurements
## 3 Estimation of distributions, moments and quantiles in deconvolution\n  problems
## 4   Kernel methods and minimum contrast estimators for empirical\n  deconvolution
##                                        authors
## 1                 Peter Hall|Alexander Meister
## 2 Aurore Delaigle|Peter Hall|Alexander Meister
## 3               Peter Hall|Soumendra N. Lahiri
## 4                   Aurore Delaigle|Peter Hall
</code></pre>

<p>We can open the abstract pages for these 4 manuscripts
using <code>arxiv_open()</code>. It takes, as input, the output of
<code>arxiv_search()</code>.</p>

<pre><code class="r">arxiv_open(deconv)
</code></pre>

<h2>Forming queries</h2>

<p>The two basic arguments to <code>arxiv_count()</code> and <code>arxiv_search()</code> are
<code>query</code>, a
character string representing the search, and <code>id_list</code>, a list of
<a href="http://arxiv.org/help/arxiv_identifier">arXiv manuscript identifiers</a>.</p>

<ul>
<li>If only <code>query</code> is provided, manuscripts matching that query are
returned.</li>
<li>If only <code>id_list</code> is provided, manuscripts in the list are
returned.</li>
<li>If both are provided, manuscripts in <code>id_list</code> that match <code>query</code>
will be returned.</li>
</ul>

<p><code>query</code> may be a single character string or a vector of character
strings. If it is a vector, the elements are pasted together with
<code>AND</code>.</p>

<p><code>id_list</code> may be a vector of character strings or a single
comma-separated character string.</p>

<h3>Search terms</h3>

<p>Generally, one would ignore <code>id_list</code> and focus on forming the <code>query</code>
argument. The aRxiv package includes a dataset <code>query_terms</code> that
lists the terms (like <code>au</code>) that you can use.</p>

<pre><code class="r">query_terms
</code></pre>

<pre><code>##               term                                      description
## 1               ti                                            Title
## 2               au                                           Author
## 3              abs                                         Abstract
## 4               co                                          Comment
## 5               jr                                Journal Reference
## 6              cat                                 Subject Category
## 7               rn                                    Report Number
## 8              all                                 All of the above
## 9    submittedDate Date/time of initial submission, as YYYYMMDDHHMM
## 10 lastUpdatedDate        Date/time of last update, as YYYYMMDDHHMM
</code></pre>

<p>Use a colon (<code>:</code>) to separate the query term from the actual query.
Multiple queries can be combined with <code>AND</code>, <code>OR</code>, and <code>ANDNOT</code>. The
default is <code>OR</code>.</p>

<pre><code class="r">arxiv_count(&#39;au:Peter au:Hall&#39;)
</code></pre>

<pre><code>## [1] 14883
</code></pre>

<pre><code class="r">arxiv_count(&#39;au:Peter OR au:Hall&#39;)
</code></pre>

<pre><code>## [1] 14883
</code></pre>

<pre><code class="r">arxiv_count(&#39;au:Peter AND au:Hall&#39;)
</code></pre>

<pre><code>## [1] 72
</code></pre>

<pre><code class="r">arxiv_count(&#39;au:Hall ANDNOT au:Peter&#39;)
</code></pre>

<pre><code>## [1] 1294
</code></pre>

<p>It appears that in the author field (and many other fields) you must
search full words, and that wild cards not allowed.</p>

<pre><code class="r">arxiv_count(&#39;au:P* AND au:Hall&#39;)
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">arxiv_count(&#39;au:P AND au:Hall&#39;)
</code></pre>

<pre><code>## [1] 568
</code></pre>

<pre><code class="r">arxiv_count(&#39;au:&quot;P Hall&quot;&#39;)
</code></pre>

<pre><code>## [1] 37
</code></pre>

<h3>Subject classifications</h3>

<p>arXiv has a set of 127 subject classifications,
searchable with the prefix <code>cat:</code>. The aRxiv package contains a
dataset <code>arxiv_cats</code> containing the abbreviations and descriptions.
Here are the statistics categories.</p>

<pre><code class="r">arxiv_cats[grep(&#39;^stat&#39;, arxiv_cats$abbreviation),]
</code></pre>

<pre><code>##   abbreviation                   description
## 1      stat.AP     Statistics - Applications
## 2      stat.CO      Statistics - Computation
## 3      stat.ML Statistics - Machine Learning
## 4      stat.ME      Statistics - Methodology
## 5      stat.TH           Statistics - Theory
</code></pre>

<p>To search these categories, you need to include either the full term
or use the <code>*</code> wildcard.</p>

<pre><code class="r">arxiv_count(&#39;cat:stat&#39;)
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">arxiv_count(&#39;cat:stat.AP&#39;)
</code></pre>

<pre><code>## [1] 3367
</code></pre>

<pre><code class="r">arxiv_count(&#39;cat:stat*&#39;)
</code></pre>

<pre><code>## [1] 17901
</code></pre>

<h3>Dates and ranges of dates</h3>

<p>The terms <code>submittedDate</code> (date/time of first submission) and
<code>lastUpdatedDate</code> (date/time of last revision) are particularly
useful for limiting a search with <em>many</em> results, so that you may
combine multiple searches together, each within some window of time,
to get the full results.</p>

<p>The date/time information is of the form <code>YYYYMMDDHHMMSS</code>, for
example <code>20071018122534</code> for <code>2007-10-18 12:25:34</code>. You can use <code>*</code>
for a wildcard for the times. For example, to get all manuscripts
with initial submission on 2007-10-18:</p>

<pre><code class="r">arxiv_count(&#39;submittedDate:20071018*&#39;)
</code></pre>

<pre><code>## [1] 196
</code></pre>

<p>But you can&#39;t use the wildcard within the <em>dates</em>.</p>

<pre><code class="r">arxiv_count(&#39;submittedDate:2007*&#39;)
</code></pre>

<pre><code>## [1] 0
</code></pre>

<p>To get a count of all manuscripts with original submission in 2007,
use a date range, like <code>[from_date TO to_date]</code>. (If you give a partial
date, it&#39;s treated as the earliest date/time that matches, and the
range appears to be up to but not including the second date/time.)</p>

<pre><code class="r">arxiv_count(&#39;submittedDate:[2007 TO 2008]&#39;)
</code></pre>

<pre><code>## [1] 55749
</code></pre>

<h2>Search results</h2>

<p>The output of <code>arxiv_search()</code> is a data frame with the following
columns.</p>

<pre><code class="r">res &lt;- arxiv_search(&#39;au:&quot;Terry Speed&quot;&#39;)
names(res)
</code></pre>

<pre><code>##  [1] &quot;id&quot;               &quot;submitted&quot;        &quot;updated&quot;         
##  [4] &quot;title&quot;            &quot;abstract&quot;         &quot;authors&quot;         
##  [7] &quot;affiliations&quot;     &quot;link_abstract&quot;    &quot;link_pdf&quot;        
## [10] &quot;link_doi&quot;         &quot;comment&quot;          &quot;journal_ref&quot;     
## [13] &quot;doi&quot;              &quot;primary_category&quot; &quot;categories&quot;
</code></pre>

<p>The columns are described in the help file for <code>arxiv_search()</code>. Try
<code>?arxiv_search</code>.</p>

<p>A few short notes:</p>

<ul>
<li>Each field is a single character string. <code>authors</code>, <code>link_doi</code>, and
<code>categories</code> may contain multiple items, separated by a vertical bar
(<code>|</code>).</li>
<li>Missing entries will have an empty character string (<code>&quot;&quot;</code>).</li>
<li>The <code>categories</code> column may contain not just the aRxiv categories
(e.g., <code>stat.AP</code>) but also codes for the
<a href="http://www.ams.org/mathscinet/msc/msc2010.html">Mathematical Subject Classification (MSC)</a> (e.g., 14J60)
and the
<a href="http://www.acm.org/about/class/1998/">ACM Computing Classification System</a>
(e.g., F.2.2). These are not searchable with <code>cat:</code> but are
searchable with a general search.</li>
</ul>

<pre><code class="r">arxiv_count(&quot;cat:14J60&quot;)
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">arxiv_count(&quot;14J60&quot;)
</code></pre>

<pre><code>## [1] 367
</code></pre>

<h2>Sorting results</h2>

<p>The <code>arxiv_search()</code> function has two arguments for sorting the results,
<code>sort_by</code> (taking values <code>&quot;submitted&quot;</code>, <code>&quot;updated&quot;</code>, or
<code>&quot;relevance&quot;</code>) and <code>ascending</code> (<code>TRUE</code> or <code>FALSE</code>). If <code>id_list</code> is
provided, these sorting arguments are ignored and the results are
presented according to the order in <code>id_list</code>.</p>

<p>Here&#39;s an example, to sort the results by the date the manuscripts
were last updated, in descending order.</p>

<pre><code class="r">res &lt;- arxiv_search(&#39;au:&quot;Terry Speed&quot;&#39;, sort_by=&quot;updated&quot;,
                    ascending=FALSE)
res$updated
</code></pre>

<pre><code>## [1] &quot;2012-01-31 05:54:46&quot; &quot;2008-06-27 08:25:01&quot;
</code></pre>

<h2>Technical details</h2>

<h3>Metadata limitations</h3>

<p>The <a href="http://arxiv.org/help/prep">arXiv metadata</a> has a number of
limitations, the key issue being that it is author-supplied and so not
necessarily consistent between records.</p>

<p>Authors&#39; names may vary between records (e.g., T. P. Speed vs. Terry
Speed vs. Terence P. Speed). Further, arXiv provides no ability to
distinguish multiple individuals with the same name (c.f.,
<a href="http://orcid.org">ORCID</a>).</p>

<p>Authors&#39; institutional affiliations are mostly missing.  The arXiv
submission form does not include an affiliation field; affiliations
are entered within the author field, in parentheses.  The
<a href="http://arxiv.org/help/prep#author">metadata instructions</a> may not be
widely read.</p>

<p>There are no key words; you are stuck with searching the free text in
the titles and abstracts.</p>

<p>Subject classifications are provided by the authors and may be
incomplete or inappropriate.</p>

<h3>Limit time between search requests</h3>

<p>Care should be taken to avoid multiple requests to the arXiv API in a
short period of time. The
<a href="http://arxiv.org/help/api/user-manual">arXiv API user manual</a> states:</p>

<blockquote>
<p>In cases where the API needs to be called multiple times in a row,
we encourage you to play nice and incorporate a 3 second delay in
your code.</p>
</blockquote>

<p>The aRxiv package institutes a delay between requests, with the time
period for the delay configurable with the R option
<code>&quot;aRxiv_delay&quot;</code> (in seconds). The default is 3 seconds.</p>

<p>To reduce the delay to 1 second, use:</p>

<pre><code class="r">options(aRxiv_delay=1)
</code></pre>

<p><strong>Don&#39;t</strong> do searches in parallel (e.g., via the parallel
package). You may be locked out from the arXiv API.</p>

<h3>Limit number of items returned</h3>

<p>The arXiv API returns only complete records (including the entire
abstracts); searches returning large numbers of records can be very
slow.</p>

<p>It&#39;s best to use <code>arxiv_count()</code> before <code>arxiv_search()</code>, so that you have
a sense of how many records you will receive. If the count is large,
you may wish to refine your query.</p>

<p>arXiv has a hard limit of around 50,000 records; for a query that
matches more than 50,000 manuscripts, there is no way to receive the
full results. The simplest solution to this problem is to break the
query into smaller pieces, for example using slices of time, with a
range of dates for <code>submittedDate</code> or <code>lastUpdatedDate</code>.</p>

<p>The <code>limit</code> argument to <code>arxiv_search()</code> (with default <code>limit=10</code>)
limits the number of records to be returned. If you wish to receive
more than 10 records, you must specify a larger limit (e.g., <code>limit=100</code>).</p>

<p>To avoid accidental searches that may return a very large number of
records, <code>arxiv_search()</code> uses an R option, <code>aRxiv_toomany</code> (with a
default of 15,000), and refuses to attempt a search that will return
results above that limit.</p>

<h3>Make requests in batches</h3>

<p>Even for searches that return a moderate number of records (say
2,000), it may be best to make the requests in batches: Use a smaller
value for the <code>limit</code> argument (say 100), and make multiple requests
with different offsets, indicated with the <code>start</code> argument, for the
initial record to return.</p>

<p>This is done automatically with the <code>batchsize</code> argument to
<code>arxiv_search()</code>.  A search is split into multiple calls, with no more
than <code>batchsize</code> records to be returned by each, and then the results
are combined.</p>

<h2>License and bugs</h2>

<ul>
<li>License:
<a href="https://github.com/ropensci/aRxiv/blob/master/LICENSE">MIT</a></li>
<li>Report bugs or suggestions improvements by <a href="https://github.com/ropensci/aRxiv/issues">submitting an issue</a> to
<a href="https://github.com/ropensci/aRxiv">our GitHub repository for aRxiv</a>.</li>
</ul>

<!-- the following to make it look nicer -->

<p><link href="http://kbroman.org/qtlcharts/assets/vignettes/vignette.css" rel="stylesheet"></link></p>

</body>

</html>
